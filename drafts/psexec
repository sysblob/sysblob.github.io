# Working with PATH and PSEXEC

Windows uses certain system environment variables in order to hold important values. One of these values is the file directories in which to search for a command when you execute from the command line. This environment variable which contains these file locations is called <span style="color: rgb(224, 62, 45);">PATH</span>. Anything we add to the <span style="color: rgb(224, 62, 45);">PATH</span> windows will be able to execute from the command line from any directory.

#### <span style="color: rgb(185, 106, 217);">An exercise to learn about PATH</span>

If I’m in the command prompt I don’t want to have to navigate to the exact directory in order to run an exe, that’s tiresome. Instead, we add a value to the PATH variable and Windows will find the exe because it will search that path. Create a folder that we will put some admin tools in. For example C:\\Admin Tools. Type in <span style="color: rgb(45, 194, 107);">“env”</span> into the Windows search bar and open System Properties.

Let’s access Environment Variables in the bottom right corner. Once inside Environment Variables click the PATH variable and click edit. Here you will see all the places Windows knows to look for programs. Let’s reference the folder we made. Click NEW and paste in the file path of our Admin Tools folder which should be “C:\\Admin Tools”. Click the necessary okay boxes to get out of the menu. Ok, now Windows will know if we reference a command it doesn’t know within the shell to look in the folder Admin Tools.

- Next let’s download some admin tools to put into our folder. A highly desirable tool is<span style="color: rgb(45, 194, 107);"> Psexec</span>, part of the PSTools suite. Psexec let’s you run files on a remote machine and is extremely powerful for administrative work. In order to work, your domain must have the admin share c$ turned on. Luckily, this is on for most domains. Microsoft references PSTools on their website and provides a download link here: [https://docs.microsoft.com/en-us/sysinternals/downloads/pstools](https://docs.microsoft.com/en-us/sysinternals/downloads/pstools).
- After downloading PSTools, unzip the contents of PSTools (the actual files not the folder) into our Admin Tools directory. It should look like this:
- Now we have some admin tools dumped into our admin tools folder which Windows knows to look for. Let’s test out some basic commands in PowerShell. First let’s pull down some system information from a computer on our domain. Try running this code within your PowerShell:

```powershell
psinfo computername
```

- Replace computername with the machine you’d like to pull information from. In the case of a remote machine on a domain you may need to append the full domain as in *[computername.domain.com](http://computername.domain.com)*. If you run psinfo without a machine name you return the localhost. **Note: The first time you run any sysinternals program you will be asked to sign a EULA. This can be signed by using the -accepteula argument (ala psinfo -accepteula). On PowerShell 7 it will simply open a Window and ask you. On default PowerShell ISE it breaks and just hangs.**
- Let’s do some fun stuff. One of my favorite uses for psexec is to take over another computer’s command prompt remotely. Here is example code for that in two different forms:

```powershell
psexec computername.domain.com cmd

psexec computername.domain.com cmd -u username
```

<p class="callout info">For username you may need to specify the domain as in domain\\username.</p>

- The first command runs cmd on a remote machine as the account you’re logged into. The second command runs cmd on a remote machine as another user. You can use either one. Adding a username without a -p argument prompts us to enter our admin password in a hidden form. This username and password is sent encrypted by psexec when it executes the command. You can include a -p if you wish to visibly see your password, either way it’s encrypted across the network. But what if you don’t stay logged on to your admin account for day to day tasks? Smart security! We have a way to use psexec under those conditions as well using a command such as this:

```powershell
psexec -u adminusername -h remotecomputername.domain.com cmd
```

- Pay attention to what’s happening here. What we’re actually doing is using psexec to recursively call itself locally, as admin, and then passing the login credentials as well as the admin token gained from that along to another psexec (it isn’t shown) that then makes the real psexec call for us. The -h parameter is what passes the elevated token to your new login session. **Note: It’s very important to note that this will cause issues if you’re on a domain that enforces smart card logins. To bypass this see [this article](https://ephams.com/2013/08/bypassing-smart-card-logon-remote-registry/)**. Here is a list of other commands PSTools is capable of:

### PSTools Commands

- *[PsExec](https://docs.microsoft.com/en-us/sysinternals/downloads/psexec)* - execute processes remotely
- *[PsFile](https://docs.microsoft.com/en-us/sysinternals/downloads/psfile)* - shows files opened remotely
- *[PsGetSid](https://docs.microsoft.com/en-us/sysinternals/downloads/psgetsid)* - display the SID of a computer or a user
- *[PsInfo](https://docs.microsoft.com/en-us/sysinternals/downloads/psinfo)* - list information about a system
- *[PsPing](https://docs.microsoft.com/en-us/sysinternals/downloads/psping)* - measure network performance
- *[PsKill](https://docs.microsoft.com/en-us/sysinternals/downloads/pskill)* - kill processes by name or process ID
- *[PsList](https://docs.microsoft.com/en-us/sysinternals/downloads/pslist)* - list detailed information about processes
- *[PsLoggedOn](https://docs.microsoft.com/en-us/sysinternals/downloads/psloggedon)* - see who's logged on locally and via resource sharing (full source is included)
- *[PsLogList](https://docs.microsoft.com/en-us/sysinternals/downloads/psloglist)* - dump event log records
- *[PsPasswd](https://docs.microsoft.com/en-us/sysinternals/downloads/pspasswd)* - changes account passwords
- *[PsService](https://docs.microsoft.com/en-us/sysinternals/downloads/psservice)* - view and control services
- *[PsShutdown](https://docs.microsoft.com/en-us/sysinternals/downloads/psshutdown)* - shuts down and optionally reboots a computer
- *[PsSuspend](https://docs.microsoft.com/en-us/sysinternals/downloads/pssuspend)* - suspends processes
- If you click each command you will see a detailed description by Microsoft as well as parameters to modify them. Finally let’s put it all together and do some basic computer maintenance. If you’re like me, you’re often adding users to remote desktop access. Let’s elevate from a normal user account to an admin one, psexec into a domain machine’s cmd, and add a user to remote desktop users via net localgroup. Here is the series of commands:

```powershell
#First we remote into the machine using elevated priv.
psexec -u adminusername -h \\\\remotecomputername.domain.com cmd

#Next we run the command to display all RDP users.
net localgroup "remote desktop users"

#Let's add a user to this group.
net localgroup "remote desktop users" username /add

#Let's remove that user.
net localgroup "remote desktop users" username /delete

#Exit from remote connection
exit

#If all commands completed successfully cmd should exit on the remote machine with a 0 error code.
```

- Note that the net localgroup commands are CMD commands and not PowerShell, after all, we’re remoted into a CMD prompt